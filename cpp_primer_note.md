[toc]

### tips

尽量使用前置`++、--`运算符，少使用后置的版本

### const引用

```c
const int &r = a;	//ok
int &const r = a;	//error: const qualitiers can not applied to `int &`
```



### const指针

弄清带有const的指针的声明含义最好的方法时**从右向左**阅读

对于`const int *pa = &a`这样的声明，应该这样理解：

>pa是一个指向int变量的指针，则*pa 是int类型的值，const限定的是 *pa，即不能够对 *pa做修改，但是可以改变 pa本身的值

对于`int *const pb` ,应该这样理解：

>pb 直接被const限制 ，说明pb 是一个常量对象，前面的`int *`说明 pb是一个常量指针。所以对于pb，可以修改`*pb`，但是不能直接修改`pb`

```cpp
	int a = 1;
	int b = 2;
	const int *pa = &a;
	int *const pb = &b;

	pa = &b;	//ok
	// *pa = 3;		//error
	// pb = &a;		//error
	*pb = 3;	//ok
	
```

### 顶层const

用名词**顶层const**来表示指针本身是个常量，用名词**底层const**表示指针所指的对象时一个常量。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算数类型，类，指针等

底层const则与指针和引用等复合类型的基本类型部分有关

### constexpr 与常量表达式

允许将变量声明为`constexpr`类型以便于由编译器来验证变量的值是否是一个常量表达式

**一般来说，如果认为变量是一个常量表达式，那就把它声明成`constexpr`类型**

一个`constexpr`指针的初始值必须是`nullptr`或0 ，或者是崔处于某个固定地址中的对象。

**`constexpr`把他所定义的对象置为了<a href="#顶层const">顶层const</a>**

### `decltype`类型指示符

`decltype`作用是选择并返回操作数的数据类型

```cpp
decltype(f()) sum = x;	//sum变量的类型与f函数返回值的类型相同
```

**`decltype((variable))`（注意是双层括号）得到的结果永远是引用，而`decltype(variable)`的结果就是`variable`的类型**

### 预处理器概述

- **`#define`**指令把一个名字设定为预处理变量
- **`#ifdef`**当且仅当变量已定义时为真,一旦检查结果为真，则执行后续操作直至遇到**`#endif`**指令为止
- **`#ifndef`**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**`#endif`**指令为止

例如

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

**预处理变量无视C++语言中关于作用域的规则**

## 第三章 字符串、向量、数组

### 3.1 命名空间的using声明

**头文件不应包含using声明**

### 3.2 标准库类型 string

## 第六章 函数

#### 6.2.6 含有可变形参的函数

`initializer_list`对象中的元素永远是常量值

#### 6.3.2 

函数的返回类型决定函数调用是否是左值。**调用一个返回引用的函数得到左值**，其他返回类型得到右值

#### 6.5.1

一旦某个形参被赋予了默认值，他后面的形参都必须有默认值（有默认值的形参排在形参列表的后面）

#### 内联函数与`constexpr`函数

把内联函数与constexpr函数放在头文件中

#### 7.1.2

成员函数必须声明在类的内部，它的定义既可以在类的内部也可以在外部

**定义在类内部的函数是隐式的`inline`函数**

#### const成员函数（常量成员函数）

特点是在成员函数的参数列表之后有一个const关键字。这里，const的作用是修改隐式this指针的类型

类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数

如果函数在概念上属于类但是不定义在类中，则它一般应该与类声明（而非定义）在同一个头文件中

#### 7.1.4 构造函数

构造函数的名字与类名相同         

构造函数中，在参数列表与函数体之间的列表称为构造函数初始值列表

构造函数可以在类的外部定义

#### 7.2.1 友元

类可以允许其他类或者函数访问它的非公有成员，方法时令其他类或者函数成为它的友元

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中

#### 7.3.1 

#### 可变数据成员

一个可变数据成员永远不会是const

#### 7.3.4

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

友元关系不存在传递性

类可以指定某个类的成员函数作为自己的友元

#### 类的作用域

对于类类型的成员使用作用域运算符访问

#### 7.5.1 

如果成员时const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过**构造函数初始值列表**为这些成员提供初值

最好令构造函数初始值的顺序与成员声明的顺序保持一致

#### 7.5.4 隐式的类类型转换

**只允许一步类类型转换**

**通过将构造函数声明为`explicit`来抑制构造函数定义的隐式转换**

**`explicit`只对一个实参的构造函数有效**

`explicit`只能在类内声明构造函数时使用，在类外部定义时不应重复

`explicit`构造函数只能用于直接初始化，不能用于拷贝初始化（因为拷贝初始化先执行了一步隐式转换，而`explicit`禁止隐式转换）

**实际上，`explicit`的作用是禁止隐式的生成临时对象**

#### 7.6 类的静态成员

必须在类的外部定义和初始化每个静态成员

在类外定义时不用再带`static`关键字

---

### 8.1.2 流的条件状态

| failbit | eofbit | badbit | goodbit |
| :-----: | :----: | :----: | :-----: |

置位变1，复位变0

#### 8.2.2 文件模式

| in     | 以读方式打开                   |
| ------ | ------------------------------ |
| out    | 以写方式打开（会丢弃已有数据） |
| app    | 每次写操作前均定位到文件末尾   |
| ate    | 打开文件后立即定位到文件末尾   |
| trunc  | 截断文件                       |
| binary | 以二进制方式进行IO             |

可以使用多种方式打开文件，不同方式之间使用`|`分隔

#### 9.2.1 迭代器

迭代器使用左开有闭区间

#### 9.3.1 向顺序容器添加元素

顺序容器的`insert`成员：在迭代器指向的元素**之前**插入值

**向一个`vector`、`string`、`deque` 插入元素会使所有指向容器的迭代器、引用和指针失效，删除不会**

当我们调用`emplace`成员函数时，是将参数传递给元素类型的构造函数

**`emplace`函数在容器中直接构造元素。传递给`emplace`函数的参数必须与元素类型的构造函数相匹配**

**迭代器解引用返回的是引用**

```cpp
c.at(n) 		//返回下标为n的元素的引用
```

**`erase` 成员函数返回指向最后一个被删元素之后的元素**

#### 9.3.4 特殊的`forward_lsit`操作

`forward_list`有一个特殊的成员函数`before_begin()`，调用它会得到一个首前迭代器（与尾后迭代器相对应）

**必须保证每次改变容器的操作之后都正确的重新定位迭代器，对`vectoer`、`string`、`deque`尤其重要**

**如果在一个循环中插入/删除`deque`、`string`、`vector`中的元素，不要缓存end返回的迭代器**

`capacity 容积`

`shrink 缩小`

`reserve 储备`

`assign 分配`

**调用`shrink_to_fit` 只是一个请求，标准库并不保证退还内存**

**当我们调用`emplace`成员函数时，是将参数传递给元素类型的构造函数，`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素**

#### 10.1

**算法永远不会执行容器的操作，算法永远不会改变容器的大小**

#### 10.2.1 只读算法

对于只读取而不改变元素的算法，通常最好用`cbegin()`和`cend()`，但是如果想要使用算法返回的迭代器，就要使用`begin()`和`end()`

#### back_inserter

当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中

**`back_inserter`算法得到的迭代器通过`push_back()`将元素添加到容器中**

当以引用方式捕获一个变量时，必须保证在`lambda`执行时变量是存在的

**隐式捕获**

默认情况下，如果一个`lambda`体包含`return`之外的任何语句，则编译器假定此`lambda`返回`void`

如果`lambda`的捕获列表为空，通常可以用函数来代替它

#### `bind`函数

将高元谓词转换为低元谓词

#### ostream_iterator 

必须将`ostream_iteator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`

`splice 拼接`

#### 11.1 使用关联容器

当从`map`提取一个元素时，会得到一个`pair`类型的对象

#### 11.2.3 pair类型

`make_pair(v1, v2)`返回一个用`v1`和`v2`初始化的类型

#### 11.3 关联容器操作

`map`的`key_type`是前一个元素的类型，**`value_type`是`pair`类型**，`mapped_type`是后一个元素的类型

`map`的前一个元素类型是`const`的

`set`的迭代器是`const`的

#### map和set的insert、emplace函数

`insert`函数返回一个`pair`，包含一个迭代器，指向具有指定指定关键字的元素以及一个指示插入成功的`bool`值

**在`multimap`和`multiset`中，键值相同的元素相邻存储**

#### 12.1.1 shared_ptr 类

使用动态内存的一个常见原因是允许多个对象共享相同的状态

#### 12.1.3

接受指针参数的智能指针构造函数是`explicit`的。因此，我们不能讲一个内置指针隐式转换为一个智能指针，**必须使用直接初始化**形式来初始化一个智能指针。

**当将一个`shared_ptr `绑定到一个普通指针是，我们就将内存的管理责任交给了这个`shared_ptr`。一旦这样做了，我们就不应该再使用内置指针来访问`shared_ptr `所指向的内存**

**永远不要用`get`初始化另一个智能指针或者为另一个智能指针赋值**

**如果使用智能指针管理的资源不是`new`分配的内存，要传递给他一个删除器（`deleter`）**

#### 12.1.6 weak_ptr

`weak_ptr`指向一个由`shared_ptr`管理的对象

将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数

由于对象可能不存在，不能直接使用`weak_ptr`访问对象，必须调用`lock()`（返回`weak_ptr`绑定的`shared_ptr`）

#### 12.2.2 `allocater`类

标准库`alloater`类定义在头文件`memory`中，它帮助我们将内存分配和对象构造分离开来

#### 13.1.1 拷贝构造函数

拷贝初始化通常使用拷贝构造函数来完成，有时使用移动构造函数来完成

编译器可以绕过拷贝构造函数

#### 13.1.2 拷贝赋值运算符

如果一个运算符是一个成员函数，其**左侧运算对象**就绑定到隐式的`this`参数,其右侧运算对象作为显式参数传递

#### 13.1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非`static`数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非`static`数据成员

析构函数没有返回值，也不接受参数

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序销毁

**隐式销毁一个内置指针类型的成员不会delete它所指向的对象**

析构函数体自身并不销毁成员。成员是在析构函数体之后隐含的析构阶段销毁的。

**在整个对象销毁过程中**，**析构函数体是作为成员销毁步骤之外的另一部分进行的**

#### 什么时候会调用析构函数

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

**如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数，反之则不一定**

**如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个考本赋值运算符，反之依然**

#### `=default`与`=delete`

`=default`生成显式要求编译器生成合成的版本

通过将拷贝构造函数与拷贝赋值运算符定义为**删除的函数**来阻止拷贝（使用`=delete`）

可以对任何函数指定`=delete`（除了析构函数）

**如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的**

#### 13.2 

**可以定义拷贝操作，使类的行为看起来像一个值或者像指针**

对于行为像值的类，**对于类管理的资源**，每个对象都应该拥有一份自己的拷贝

编写赋值运算符时，有两点需要记住：

1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作
2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

**一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象**

#### 13.3 在赋值运算符中使用swap

**定义swap的类通常用swap来定义他们的赋值运算符**

这些运算符使用了一种名为**拷贝并交换**的技术，这中技术将左侧运算对象与右侧运算对象的一个副本进行交换

**使用拷贝并交换的赋值运算符自动就是异常安全的，且能正常处理自赋值**

#### 13.6.1 右值引用

前置递增/递减运算符返回左值，后置递增/递减运算符返回右值

变量是左值，右值引用是一个变量，所以右值引用是左值，不能将一个右值引用绑定到一个右值引用类型的变量上，但可以将一个左值引用绑定到右值引用类型的变量上。

#### 13.6.2 

移动构造函数的第一个参数是该类类型的一个**右值引用**（非常量）

除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态：销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属于新创建的对象。

移动操作通常不会抛出任何异常，因此在编写一个不抛出异常的移动操作时，我们应该将此事通知标准库

**不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`**

在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设

**如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为他合成移动构造函数和移动赋值运算符**

**只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符**

**定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认的被定位为删除的**

#### 移动迭代器

使用标准库的`make_move_iterator`函数将一个普通迭代器转换为移动迭代器

移动迭代器在其他方面与普通迭代器相同，只是解引用时返回右值引用

#### 右值和左值引用成员函数

在参数列表后放置一个**引用限定符**指出该成员函数只能由左值（或右值）调用

```cpp
Foo &f0() &;
Foo &f1() &&;
```

如果引用限定符与const限定同时出现引用限定符必须跟在const限定的后面

如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加

对象是左值就意味着该对象有其他的用户，在没有明确语义的前提下不能任意修改该对象

#### 14.1 

当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个

不建议重载逻辑与、逻辑或、逗号、&&、|| 、取地址（&）等运算符

- 赋值（=）、下标（[ ]）、调用（( )）和成员访问(->)运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，一如算术、相等性、关系和位运算符等，因此他们通常应该是普通的非成员函数。
- 输入输出运算符必须是非成员函数，并且因为IO运算符常常要读写非公有数据成员，所以常常被声明为友元

当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。

输入运算符必须处理输入可能失败的情况，而输出运算符不需要

#### 14.3 算术和关系运算符

如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运符。

定义`==`的同时也要定义`!=`

#### 14.5 下标运算符

最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保不会给返回的对象赋值。

#### 14.7 成员访问运算符

重载的箭头运算符必须返回类的指针或者自定了箭头运算符的某个类的对象

重载的箭头运算符指明要通过重载的箭头运算符来访问类里的哪个对象的成员

#### 14.8 标准库函数对象

直接比较两个无关的指针会产生未定义的行为，不过**标准库函数对象**允许这种比较

#### 14.9.1 类型转换运算符

类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型，类型转换函数的一般形式如下

```cpp
operator type() const;	//type表示要转换的类型
```

对于类来说，定义向`bool`的类型转换是比较普遍的现象，向其他类型的转换比较少见

#### 显式的类型转换运算符

```cpp
explicit operator type() const;	//type表示要转换的类型
```

`operator bool` 一般定义成`explicit`的

#### 14.9.2 避免有二义性的类型转换

不要为类定义相同的类型转换:如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符

不要在定义中定义两个及两个以上转换源或转换目标是算术类型的转换。

如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题

#### 15.2.1 定义基类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

派生类需要对虚函数提供自己的新定义以覆盖（override）从基类继承而来的新旧义

**在c++语言中，基类必须将它的两种成员区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数，对于前者，基类常将其定义为虚函数（virtual）**

如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数

#### 15.2.2 定义派生类

派生列表中的访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似与其他的成员函数，派生类会直接继承其在基类中的版本

在类后加一个关键字`final`，表明该类禁止其他类继承它

派生类的声明中包含类名但不包含派生列表

#### 15.2.3 类型转换与继承

**可以将基类的指针或引用绑定到派生类对象上（指向基类的指针也可以指向派生类）**

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。

#### 15.3 虚函数

**动态绑定只有当我们通过指针或引用调用虚函数时才会发生，当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来**

一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它被覆盖的基类函数完全一致。

如果我们已经把函数定义成`final`了，则之后任何尝试覆盖该函数的操作都将引发错误

```cpp
struct B {
    virtual void f1(int) const;
    virtual void f2();
    void f3()
};

struct D2: B {
    //从B继承f2()和f3(), 覆盖f1(int)
    void f1(int) const final;	//不允许后续的其他类覆盖f1(int)
};

struct D3: D2 {
    void f2();				//正确，覆盖从间接基类B继承而来的f2
    void f1(int) const;		//错误，D2已经将f1声明成final
};
```

`final`和`override`说明符出现在形参列表（包括任何`const`或引用修饰符）以及位置返回类型之后

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

使用作用域运算符可以强迫执行虚函数的特定版本，通常情况下，只有成员函数和友元中的代码才需要使用作用域运算符来回避虚函数的机制

#### 15.4 抽象基类

纯虚函数：通过在函数体的文职书写=0 就可以将一个虚函数说明为纯虚函数。如下

```cpp
double net_price(std::size_t) const = 0;
```

**我们不能在一个类的内部为一个纯虚函数提供函数体，但可以在外部提供**

含有纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他鳄梨可以覆盖该接口。**我们不能直接创建一个抽象基类的对象，但是可以创建其派生类的对象**

#### 15.5 访问控制与继承

**派生类的成员或友元只能通过派生类对象（不能通过基类对象来访问）来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权**

```cpp
class Base {
protected:
	int prot_mem;
};

class Sneaky : public Base {
	friend void clobber(Sneaky&);	//能访问Sneaky::prot_mem
	friend void clobber(Base&);		//不能访问Sneaky::prot_mem
	int j;
};
```

**派生访问说明符对于派生类的成员（及友元）能够访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关**

**派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限**

对于代码的指定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

友元关系不能继承

using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定

- 只有当D公有的继承B时，**用户代码**才能使用派生类向基类的转换；如果D继承B的方式时受保护的或者私有的，则**用户代码**不能使用该转换
- 不论D以什么方式继承B，**D的成员函数和友元**都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于**派生类的成员和友元**来说永远是可访问的。
- 如果D继承B的方式是公有的或者受保护的，则**D的派生类的成员和友元**可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。

**可以将“派生类向基类的转换”看做基类B的一个`public`成员**

#### 15.6 继承中的类作用域

我们能够使用那些成语是由对象的静态类型决定的，与动态类型无关

与其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字

**不过可以通过使用作用域运算符来使用隐藏的基类成员**

**虚析构函数将阻止合成移动操作**

#### 15.7.3 派生类的拷贝控制成员

和构造函数及赋值运算符不同的是，析构函数只销毁派生类自己分配的资源，派生类对象的基类部分是自动销毁的。

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本

#### 15.7.4 继承的构造函数

派生类继承基类构造函数的方式是提供一条注明了基类名的using声明语句

```cpp
class Bulk_Quote : public Disc_Quote {
public:
    using Disc_Quote::Disc_Quote;
    double net_price(std::size_t) const;
};
```

和普通成员的using声明不同，一个构造函数的using声明不会改变该构造函数的访问级别

当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。

#### 15.8 容器与继承

当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，**因此容器和存在继承关系的类型无法兼容**

#### 16.1 函数模板

非类型模板参数的模板实参必须是常量表达式

模板的头文件通常既包括声明也包括定义

**为了引用类模板或函数模板的一个特定实例，必须首先声明模板自身**

#### 16.2 类模板

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

**在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参**

```cpp
//模板类型别名
template<typename T> using twin = pair<T, T>
twin<string> authors;	//authors是一个pair<string, string>
```

类模板的static成员：每个类模板的实例都有其自己的static成员实例

对于类模板的static成员，应该定义为模板

```cpp
template<typename T> size_t Foo<T>::ctr=0	//ctr是类FOO的一个static成员
```

#### 16.1.3 模板参数

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。

**默认情况下，c++假定通过作用域运算符访问的名字不是类型**

**使用`typename`关键字显示告诉编译器该名字是一个类型**

#### 默认模板实参

```cpp
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
```

如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些实参，就必须在模板名之后加一个空尖括号对

```cpp

template <typename T = int> class Numbers {
public:
	Numbers(T v= 0): val(v) {  }
private:
	T val;
};
```

#### 16.1.4 成员模板

一个类可以包含本身是模板的成员函数。这中成员函数称为成员模板。**成员模板不能是虚函数**

**当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，成员模板的参数列表在后，如下**

```cpp
template <typename T>
template <typename It>
	Blob<T>::Blob(It b, It a) //do something
```

#### 显示实例化

一个显式实例化有如下形式

```cpp
extern template class Blob<string>；	        	//实例化声明
template int compare(const int&, const int&);   //实例化定义
```

当编译器遇到`extern`模板声明时，他不会在本文件中生成实例化代码。讲一个实例化声明为`extern`就表示承诺在程序其他位置有该实例化的一个非`extern`模板声明（定义）

`extern`声明必须出现在任何使用此实例化版本的代码之前

对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义，模板的实例化代码也会出现在此位置。

**一个模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数，因此，我们用来显示实例化的一个类模板的类型，必须能够用于模板的所有成员**



#### 16.2.1 类型转换与模板类型参数

**将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换**

**如果形参是引用，则数组不会转换为指针**

如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数

```cpp
template <typename A, typename B>
int compare(const A& v1, const B& v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

如果函数参数类型不是模板参数，就进行正常的类型转换

```cpp
#include <fstream>
#include <iostream>
#include <ostream>

using namespace std;

template <typename T> 
ostream &print(ostream &os, const T &obj)
{
	return os << obj;
}
int main(void)
{
	ofstream f("in");
	print(f, 122);	//ofstream 转换为ostream
	return 0;
}
```

#### 显式模板实参

```cpp
template <typename T1, typename T2, typename T2>
T1 sum(T2 , T3);
```

没有任何函数实参的类型可用来推断T1的类型，每次调用sum时必须为T1提供一个显式模板实参，如下

```cpp
sum<long long>(i, ing);
```

**对于模板类型参数已经显式指定了的函数实参，进行正常的类型转换，如下**

```cpp
long lng;
compare(lng, 1024);			//错误：模板实参不匹配
compare<long>(lng, 1024);	//正确：实例化compare(long, long)
compare<int>(lng, 1024);	//正确：实例化compare(int, int)
```

#### 16.2.3 尾置返回类型与类型转换

```cpp
template <typename It>
??? &fcn(It beg, It end)
{
    return *beg;
}
```

我们不知道`fcn`函数的返回类型是什么，但是我们知道其类型可以用`decltype(*beg)`来表示。所以可以用`decltype(*beg)`来表示返回类型。

但是在编译器遇到函数参数列表时`beg`是不存在的，所以，必须使用尾置返回类型,如下:

```cpp
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    return *beg;
}
```

## **解引用运算符返回一个左值，因此`decltype(*beg)`推断出的类型为一个引用 **

#### 进行类型转换的标准库模板类

所有迭代器操作都不会生成元素，只能生成元素的引用，为了获得元素类型，我们可以使用标准库的类型转换模板，这些模板定义在头文件`type_traits`中。

可以使用`remove_reference`消除引用获得元素类型。

```cpp
template <typename It>
auto fcn(It beg, It end) ->
	typename remove_reference<decltype(*beg)>::type
{
	return *beg;
}
```

#### 16.2.4 函数指针和实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用该函数指针的类型来推断模板实参

#### 引用折叠与右值引用参数

- 当我们将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数（如T&&）时，编译器推断模板类型参数为实参的左值引用类型（即`T = int&` 而非`int`）
- 如果间接创建一个引用的引用（通过类型别名或者模板类型参数间接定义），则这些引用形成了"折叠"，折叠规则如下
    1. `X&& &&`折叠为`X&&`
    2. 其他的引用的引用全部折叠为`X&`(即左值引用)

**引用折叠只能用于间接创建的引用的引用，如类型别名或模板参数**

**根据以上规则，以`T&&`作为函数形参的函数，既可以传递左值也可以传递右值, 传递左值时，函数参数被实例化为一个普通的左值引用`T&`，传递右值时，函数参数被实例化为`T&&`**

以上两个规则导致了两个重要结果

- 如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值
- 如果实参是一个左值，则推断处的模板实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数(T&)

```cpp
template <typename T> void f(T&&)		//绑定到非const右值
template <typename T> void f(const T&)	//绑定到左值和const右值
```

非const右值：

- 字面量：`12`,`“hello world”`

- 非`const`类型的变量，经过`std::move`后得到的量，如：

    ```cpp
    int i = 12;
    std::move(i)；	//非const右值
    const int i1 = 12;
    std::move(i1);		//const右值
    ```

    `std::move()`是一个模板，它的函数原型为:

    ```cpp
    template <typename T>
    typename std::remove_reference<T>::type&& 
    move(T&& t)  noexcept
    {
    return static_cast<typename remove_reference<T>::type&&>(t)
    }
    ```

#### 16.2.7 转发

**通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息**

**如果一个函数参数是指向模板类型参数的右值引用(T&&)，它对应的实参的`const`属性和左值/右值属性将会得到保持**

#### 在调用中使用`std::forward`保持类型信息

**通常情况下，使用`forward`传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，`forward`可以保持给定实参的左值/右值属性**

#### 16.3 重载与模板

函数模板可以被另一个模板或一个普通非模板函数重载

重载时，有多个函数提供同样好的匹配：

- 如果同样好的函数中只有一个是非模板函数，则选择此函数
- 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个比其他模板更特例化，则选择此模板
- 否则，此调用有歧义

**当有多个重载模板对一个调用提供同样好的匹配时，编译器会选择最特例化的版本**

**对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本**

**在定义任何函数之前，记得声明所有重载的版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本**

#### 16.4 可变参数模板

一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为**参数包**

存在两种参数包：

- 模板参数包，表示零个或多个模板参数
- 函数参数包，表示零个或多个函数参数

`typename...`指出接下来的参数表示零个或多个类型的列表

一个类型后面跟一个省略号表示零个或多个给定类型的非类型参数的列表

#### sizeof...运算符

当我们需要直到包中有多少元素时，可以使用`sizeof...`运算符

#### 16.4.1 编写可变参数函数模板

**可变参数函数通常都是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还要定义一个与可变参数函数同名的非可变函数, 如下**

```cpp

template <typename T>
ostream& print(ostream &os, const T &t)
{
	return os << t;
}

template <typename T, typename... Args>
ostream& print(ostream &os, const T& t, const Args&... rest)
{
	os << t << ", ";
	return print(os, rest...);
}
```

当定义可变参数版本的`pinrt`时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。

#### 16.4.2 包扩展

**扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号(...)来触发操作**

```cpp
template <typename T, typename... Args>
ostream& 
print(ostream &os, const T& t, const Args&... rest)       //扩展Args
{
	os << t << ", ";
	return print(os, rest...);			//扩展rest
} 
```

第一个扩展操作扩展模板参数包，为`print`生成函数参数列表。第二个扩展操作出现在对`print`的调用中。此模式为`print`调用生成实参列表

对于函数调用:

```cpp
int i; string s;
print(cout, i, s, 42);
```

第一个扩展结果如下：

```cpp
ostream&
print(ostream&, const int&, const string&, const int&);
```

第二个扩展发生在对`print`的递归调用中，扩展结果如下

```cpp
print(cout, s, 42);
```

#### 16.4.3 转发参数包

**可变参数函数通常将它们的参数转发给其他函数**

#### 16.5模板特例化

当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本

**一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。**

**当我们特例化一个函数模板时必须为原模板中的每个模板参数都提供实参。为了指出我们在实例化一个模板，应使用关键字`template`后跟一个空尖括号对(<>)。空尖括号指出我们将为原模板的所有模板参数提供实参**

**当我们定义一个特例花版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配**

```cpp

template <typename T>
int compare(const T& v1, const T& v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

template <>
int compare(const char* const &p1, const char* const &p2)
{
	return strcmp(p1, p2);
}
```

当定义函数模板的特例化版本时，我们本质上接管了编译器的工作

**一个特例化版本本质上是一个实例，而非函数名的一个重载版本**

**特例化的本质是实例化一个模板，而非重载它，因此，特例化不影响函数匹配**

**模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本**

#### 类模板部分特例化

可以指定一部分而非所有模板参数，或是**参数的一部分而非全部特性**

一个部分特例化的类模板还是一个模板

**只能部分特例化类模板，不能部分特例化函数模板**

部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本

#### 特例化类的成员

可以只特例化特定成员函数而不是特例化整个类。

#### 17.2 bitset 类型

`bitset`类定义在头文件`bitset`中

#### 17.3 正则表达式库

定义`regex`时指定的标志

| icase      | 在匹配过程中忽略大小写         |
| ---------- | ------------------------------ |
| nosubs     | 不保存匹配的子表达式           |
| optimize   | 执行速度优先与构造速度         |
| ECMAScript | 使用ECMAScript指定的语法       |
| basic      | 使用POSIX基本的正则表达式语法  |
| extended   | 使用POSIX扩展的正则表达式语法  |
| awk        | 使用POSIC版本的`awk`语言的语法 |
| grep       | 使用POSIX版本的grep版本的语法  |
| egrep      | 使用POSIX版本的egrep版本的语法 |

​                                           

| 如果输入序列类型 | 则使用正则表达式类                          |
| ---------------- | ------------------------------------------- |
| string           | regex, smatch,ssub_match,sregex_iterator    |
| const char*      | regex,cmatch,csub_match,cregex_iterator     |
| wstring          | wregex,wsmatch,wssub_match,wsregex_iterator |
| const wchar_t*   | wregex,wcmatch,wcsub_match,wcregex_iterator |

**使用符号`$`后跟字表达式的索引号来表示一个特定的子表达式**

```cpp
$2.$5.$7
```

#### 17.4.1 随机数引擎和分布

随机数引擎、分布类型是函数对象类，分布类型接受一个随机数引擎作为参数

随机数发生器是值分布对象和引擎对象的结合

**编写生成随机数序列的正确方法是将引擎和分布对象都声明成`static`的**

一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为`static`的。否则，每次调用函数都会生成相同的序列

#### 17.5.3 流随机访问

绑定到`cin`、`cout`、`cerr`、`clog`的流不支持随机访问，`istream`和`ostream`也不支持随机访问。

在流中只能有一个标记

seek中的偏移量可正可负。这以为这可以在刘正向前或向后移动。

计算偏移量时要包含每行末尾的换行符

#### 18.1.1 抛出异常

抛出异常时：

- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

`<stdexcept>`定义的异常类:

| `exception`        | 最常见的问题                                   |
| ------------------ | ---------------------------------------------- |
| `runtime_error`    | 只有在运行时才能检测处的问题                   |
| `range_error`      | 运行时错误：生成的结果超出了有意义的值域范围   |
| `overflow_error`   | 运行时错误：计算上溢                           |
| `underflow_error`  | 运行时错误：计算下溢                           |
| `logic_error`      | 程序逻辑错误                                   |
| `domain_error`     | 逻辑错误：参数对应的结果值不存在               |
| `invalid_argument` | 逻辑错误：无效参数                             |
| `length_error`     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| `out_of_range`     | 逻辑错误：使用一个超出有效范围的值             |

`new`头文件中定义了`bad_alloc`异常类型

`type_info`头文件定义了`bad_cast`异常类型

**栈展开过程中对象会被自动销毁**

**处于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个`try`语句块中，并且在析构函数内部得到处理.**

在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常

**当抛出一条表达式时，该表达式的静态编译时类型（静态类型而不是动态类型）决定了异常对象的类型**

如果一条`throw`表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出

#### 18.1.2 捕获异常

在异常匹配的过程中，绝大多数的类型转换都不允许，除了以下外，要求异常的类型与catch声明的类型是精确匹配的：

- 允许从非常量向常量的转换
- 允许从派生类向基类的类型转换
- 数组被转换成指针，函数被转换成指针

**如果在多个catch语句的类型之间存在这继承关系，则我们应该吧继承链低端的类放在前面，而将继承链顶端的类放在后面**

#### 重新抛出

重新抛出语句:

```cpp
throw;	//一个空的throw语句
```

重新抛出语句只能用在catch语句内部或catch语句直接或间接调用的函数中。

#### 捕获所有异常的处理代码

使用省略号作为异常声明，这样的处理代码称为捕获所有异常的处理代码

```cpp
void mainip() {
	try {
        // do something
    } catch(...) {
        //处理异常的某些特殊操作
        throw;	//重新抛出语句
    }
}
```

如果`catch(...)`和其他catch语句一起出现，则`catch(...)`必须放在最后

#### 18.1.3 函数try语句块与构造函数

要想处理构造函数初始值抛出的异常，必须将构造函数写成**函数try语句块**的形式。函数try语句块使得一组catch语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）

```cpp
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il)
    try :data(std::make_shared<std::vector<T>>(il)) {
	// 空函数体
} catch (const std::bad_alloc &e) { handle_out_of_memory(e); }
```

#### 18.1.4 noexcept 异常说明

通过提供`noexcept`说明指定某个函数不会抛出异常

在成员函数中，`noexcept`说明符需要跟在`const`及引用限定符之后，而在`final`，`override`或虚函数`=0`之前

一旦一个`noexcept`函数抛出了异常，程序就会调用`terminate`以确保遵守不再运行时抛出异常的承诺。因此`noexcept`可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。

**通常情况下，编译器不能也不必在编译时验证异常声明**

异常说明的实参

```cpp
void f() noexcept(true);		// f不会抛出异常
void g() noexcept(false);		// g可能抛出异常
```



#### noexcept 运算符

```cpp
void f() noexcept(noexcept(g()));		//f和g的异常说明一致
```

`noexcept`有两次含义：

- 当跟在函数参数列表后面时它是异常说明符
- 当作为`noexcept`异常说明的`bool`实参出现时，他是一个运算符

#### 异常说明与指针、虚函数和拷贝控制

- 函数指针及该指针所指的函数必须具有一致的异常说明
- 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的对象也必须做出同样的承诺。与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。
- 如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是`noexcept`的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是`noexcept(false)`。而且，如果我们定义了一个析构函数但是没有为它提供异常声明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。

#### 18.1.5 异常类层次

```
exception
|- bad_cast
|- bad_alloc
|- runtim_error
   |- overflow_error
   |- underflow_error
   |- range_error
|- logic_error
   |- domain_error
   |- invalid_argument
   |- out_of_range
   |- length_error
```

**面向应用的异常类常常继承自标准异常类**

#### 18.2.1 命名空间的定义

`#include`应该出现在打开命名空间的操作之前

#### 未命名的命名空间

```cpp
namespace {
    int i;
}
```

未命名的命名空间中定义的变量拥有静态生命周期（相当与静态变量）：他们在第一次使用前创建，并且直到程序结束才销毁。

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。

**在文件中进行静态声明的做法已经被c++标准取消了，现在的做法是使用未命名的命名空间**

#### 命名空间的别名

```cpp
namespace primer = cplusplus_primer;
```

#### using 声明

一条`using`声明语句看可以出现在全局作用域、局部作用域、命名空间作用域以及类作用域中。**在类作用域中，这样的声明语句只能指向基类成员**

#### using指示

**`using`指示具有将命名空间成员提升到包含命名空间本身和`using`指示的最近作用域的能力**

```cpp
using namespace std;		//指示命名空间`std`中的所有名字都可见
```

全局作用域的使用：

```cpp
int a;		//a定义在全局作用域
int main()
{
    ++::a;		// 指明使用全局作用域中的a;
}
```

#### 实参相关的查找与类类型实参

对于命名空间中名字的隐藏规则来说有一个重要的例外：**当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间**。

#### 友元声明与实参相关的查找

**一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们恩威他是最近的外层命名空间的成员**

#### 18.3.1 多重继承

派生类中基类的构造顺序与派生列表中基类出现的顺序保持一致。

#### 18.3.2 类型转换与多个基类

编译器不会在派生类向基类的集中转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好，因此，重载时会产生二义性。

#### 18.3.3 多重继承下的类作用域

在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中。

在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。**如果名字在多个基类中被找到，则对该名字的使用具有二义性（应该在该名字前加上作用域限定符再使用）**

要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本

#### 18.3.4 虚继承

在C++中，通过**虚继承**的机制解决可能继承同一个基类两次的问题。

虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类。**在这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象**

```cpp
// virtual 和 public 的顺序随意
class Raccoon: public virtual ZomAnimal { };
class Raccoon: virtual public ZooAnimal { };
```

#### 18.3.5 构造函数与虚继承

**在虚派生中，虚基类是由最底层的派生类初始化的（不是一层一层的）绕过间接基类，直接初始化虚基类**

含有虚基类的对象的构造顺序与一般的顺序稍有差别：**首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分**，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化

**虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关**

#### 19.1.1 重载new 和 delete

`operator delete`和 `operator new`是隐式静态的。因为`operator new`用在对象构造之前，`operator delete`用在对象销毁之后。

`new`表达式的执行过程：

- 调用`operator new`函数分配内存空间
- 执行构造函数
- 返回指向该对象的指针

`delete`表达式的执行过程

- 调用析构函数
- 调用`operator delete`释放内存

如下是编写`operator new`和`operator delete`的一种简单方式

```cpp
void *operator new(size_t size)
{
    if (void *mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}

void operator delete(void *mem)
{
    free(mem);
}
```

定位`new`表达式允许我们在一个特定的、预先分配的内存地址上构造对象

**传给定位`new`的指针甚至不需要指向动态内存。**

**调用析构函数会销毁对象，但不会释放内存**

#### 19.2 RTTI（运行时类型识别）

- `typeid`运算符，用于返回表达式的类型
- `dynamic_cast`，用于将基类的指针或引用安全的转化成派生类的指针或引用。

这两个运算符适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。

如果一条`dynamic_cast`语句的转换目标是指针类型并且失败了，则结果为0，

如果一条`dynamic_cast`语句的转换目标是引用类型并且失败了，则将抛出一个`bad_cast`异常。

**当`typeid`作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译类型**

`typeid`是否需要运行时检查决定了表达式是否会被求值。**只有当类型含有虚函数时，编译器才会对表达式求值。**

#### 19.4 类成员指针

**成员指针**是指可以指向类的非静态成员的指针

#### 19.4.1 数据成员指针

```cpp
const string Screen::*pdata;
```

上述语句将`pdata`声明成“一个指向`Screen`类的`const string`成员的指针”

**常规的访问控制规则对成员指针同样有效**

**与普通函数不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则，即使用成员函数的指针时必须用`&`号显示指出**

#### 19.5 嵌套类

嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何其他类型成员一样使用嵌套类的名字。

#### 19.6 union

`union`不能含有引用类型的成员，除此之外，它的成员可以是绝大多数类型。

#### 19.7 局部类

局部类：定义在函数内部的类。

局部类不能使用函数作用域中的变量，但是可以使用外层作用域中的名字。

局部类也可以嵌套。

#### 19.8 固有的不可移植的特性

#### 19.8.1 位域

类可以将其数据成员定义成位域，在一个位域总含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

```cpp
typedef unsigned int Bit;
class File {
    Bit mode: 2;				//mode 占2位
    Bit modified: 1;			//modified 占1位
    Bit prot_owner: 3;			// prot_owner占3位	
    Bit prot_group: 3;			//prot_group 占3位
    Bit prot_world: 3;			//prot_world 占3位
} 
```

通常情况下最好将位域设置为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。

**取地址运算符不能作用于位域**

#### 19.8.3 链接指示：`extern "C"`

**要想把c++代码和其他语言编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且，这个编译器与当前的c++编译器是兼容的。**

```cpp
//单语句链接指示
extern "C" size_t strlen(const char*);

//复合语句链接指示
extern "C"
{
    int strcmp(const char*, const char*);
    char* strcat(char*, const char*);
}
```

